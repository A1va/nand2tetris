# [虚拟机Ⅱ: 程序控制 Program Control]

### [背景知识]

上一节介绍9个算术指令、逻辑指令以及内存访问指令(push/pop segment<8> index)是如何利用基本**栈式机(stack machine)**操作来进行计算的。本节将在上节基础上描述**程序控制流(program flow)命令**和**子程序调用(subroutine calling)命令**是如何在**栈式机**实现的。

对于在运行期的每个**子程序调用**，底层必须处理下面的一些细节。可以利用**栈式机**来方便的完成，事实上**栈式结构**本身的优势就在于处理类似的问题。

- 将参数从调用者(caller)传递给被调用者(called subroutine)。（参数传递）
- 在跳转并执行被调用者之前，先保存调用者的状态。（现场保护）
- 为被调用者使用的局部变量分配内存空间。（内存分配）
- 跳转并执行被调用者。（子程序执行）
- 将被调用者的运行结果返回给调用者。（参数传递）
- 在从被调用者返回之前，回收其使用的内存空空间。（回收调用空间）
- 恢复调用者的状态。（现场恢复）
- 返回到调用语句之后的下一条语句继续执行。（恢复现场）



- 虽然子程序调用链可以具有任意深度，可以有任意的递归，但是**在任何时刻，只有调用链顶部的子程序才能被执行**，而处于调用链中其他子程序将一直等待到该子程序执行完毕才能继续执行。子程序调用的实现过程中，这种**后进先出**的处理方式和**栈区**数据结构的操作方式吻合。

<img src="C8-虚拟机Ⅱ 程序控制.assets/image-20200924203308549.png" alt="后进先出" style="zoom:67%;" />

- 

![函数命令的VM实现](C8-虚拟机Ⅱ 程序控制.assets/image-20200924204022900.png)



- 

![全局栈区](C8-虚拟机Ⅱ 程序控制.assets/image-20200924204140804.png)