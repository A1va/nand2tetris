# [机器语言 Machine Language]

借由机器语言，程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作。

**This chapter is Difficult.**

### [背景知识]

​		为了对机器语言作一般性描述，只须要集中讨论三个主要的抽象体上：**处理器(processor)**、**内存(memory)**以及一组**寄存器(registers)**。

#### 1.Machines

​		**机器语言(machine language)**利用**处理器**和**寄存器操控内存**。

​		**内存(memory)**	用来储存数据和指令的硬件设备。所有内存具有相同的结构：一个连续的固定宽度的单元序列，也称为**字(word)**或**内存单元**，每个内存单元都有一个唯一的**地址(address)**。因此可以通过地址描述任一内存单元。

​		**处理器**	**中央处理器**或**CPU(Central Processing Unit)**,是执行一组固定基本操作的设备。包括：算术操作、逻辑操作、内存存取操作和控制操作。操作对象都是二进制数值。

​		**寄存器**	内存访问较慢，需要较长的指令格式（一个地址可能需要32位）。因此，处理器都配有一些寄存器，每个寄存器只存储一位。紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地操控数据和指令。



#### 2.Languages

​		16-位的指令包含四个4bit的位域(fileds)：最左边的域是CPU的操作编码，剩下的三个部分表示该操作的操作数。

​		**二进制码** 封装成 **汇编(assembly language)**

​		汇编通过文本处理器编写，并由**汇编编译器(assembler)**将汇编程序 翻译成 **二进制码**



#### 3.Commands

​		**算术操作和逻辑操作**	加减、布尔操作（按位取反、移位…）

​		**内存访问**	内存访问命令分两类。第一类是**算术操作和逻辑操作**，不仅可以操控寄存器，还可以操控指定的内存单元。第二类，所有计算机都会使用`load`和`store`命令，用来在寄存器和内存之间传递数据。这些命令可能会应用某些类型的寻址方式，在指令中指定目标内存单元的地址。三种绝大多数计算机支持的寻址方式：
 - ​	**直接寻址(Direct Addressing)**		最常用的寻址方式。直接 或 用符号表示内存单元的地址。

```haxe
LOAD R1, 67  // R1 <- Memory[67]
// 或者假设bar指向内存地址67，那么就有：
LOAD R1, bar  // R1 <- Memory[67]
```

- ​	**立即寻址(Direct Addressing)**		这种寻址方式用来加载常数——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。

```haxe
LOADI R1, 67  // R1 <- 67
```

- ​	**间接寻址(Direct Addressing)**		这种寻址方式用来处理**指针(pointer)**——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。

```haxe
// 将x = foo[j] or x = *(foo+j)翻译成汇编语言
ADD R1, foo, j  // R1 <- (foo+j)
LOAD* R2, R1  // R2 <- Memory[R1]，取值到R2
STR R2, x  // x <- R2，将值赋给x(内存单元)
```

​		当数组在高级语言程序(C/Java…)被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用foo来指代该内存单元组的**基地址(base address)**。于是当编译器以后遇到表示数组单元的符号**(eg: foo[j])**时，解析地址：`foo的基地址 + (j × 单个数组元素所占的字节)`。



​		**控制流程**		程序通常以先行执行，但也包含分支：**反复**(repetition, 跳回到循环的初始位置)、**有条件的执行**（conditional executioin, 若false向前跳到`if-then`语句之后）、**子程序调用**（subrouting calling, 跳到另一代码段的第一条命令处）

```haxe
// 高级实现
while (R1 >= 0){
    code 1
}
code 2
    
// 底层实现
// while循环结构的典型翻译
beginWhile
    JNG R1, endWhile  // if R1<0 goto endWhile
    // code 1 的翻译
JMP beginWhile  // goto beginWhile
endWhile:
	// code 2 的翻译
```



### [Hack机器语言规范详述]

#### 1.概述

​		Hack是一个基于冯·诺伊曼架构的16-位计算机，由一个CPU、两个独立的内存模块（instruction memory指令内存  和  data memory数据内存），以及两个内存映射I/O设备（显示器和键盘）组成。

​		**内存地址空间**		Hack程序员要了解，有两个不同的地址空间：**指令地址空间**（instruction memory**指令内存**），**数据地址空间**（data memory**数据内存**）。两个内存区16-位宽，由15-位地址空间，意味着两个内存可设定的最大地址都是`32K`的`16-bit word`**(2^15^ = 32 × 1024 = 32K)**

​		CPU只能执行存储在指令内存中的程序。指令内存是只读设备，程序通过某种外部方法被加载到指令内存中（加载新程序，就像游戏机更换游戏卡切换游戏）.  Hack平台的硬件仿真器提供一种方法，将某文本文件中用机器语言编写的程序加载到指令内存中。

​		**寄存器(Registers)**		Hack程序员要接触两个称为D和A的16-位寄存器，能够被算数和逻辑指令显式地操控(eg: `A = D-1`或`D = !A`)。D只作为数据寄存器（用来储存数据值）；A既可以作为数据寄存器，也可以作为地址寄存器（）。

