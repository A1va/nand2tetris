# [机器语言 Machine Language]

借由机器语言，程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作。

**This chapter is Difficult.**

### [背景知识]

​		为了对机器语言作一般性描述，只须要集中讨论三个主要的抽象体上：**处理器(processor)**、**内存(memory)**以及一组**寄存器(registers)**。

#### 1.Machines

​		**机器语言(machine language)**利用**处理器**和**寄存器操控内存**。

​		**内存(memory)**	用来储存数据和指令的硬件设备。所有内存具有相同的结构：一个连续的固定宽度的单元序列，也称为**字(word)**或**内存单元**，每个内存单元都有一个唯一的**地址(address)**。因此可以通过地址描述任一内存单元。

​		**处理器**	**中央处理器**或**CPU(Central Processing Unit)**,是执行一组固定基本操作的设备。包括：算术操作、逻辑操作、内存存取操作和控制操作。操作对象都是二进制数值。

​		**寄存器**	内存访问较慢，需要较长的指令格式（一个地址可能需要32位）。因此，处理器都配有一些寄存器，每个寄存器只存储一位。紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地操控数据和指令。



#### 2.Languages

​		16-位的指令包含四个4bit的位域(fileds)：最左边的域是CPU的操作编码，剩下的三个部分表示该操作的操作数。

​		**二进制码** 封装成 **汇编(assembly language)**

​		汇编通过文本处理器编写，并由**汇编编译器(assembler)**将汇编程序 翻译成 **二进制码**



#### 3.Commands

​		**算术操作和逻辑操作**	加减、布尔操作（按位取反、移位…）

​		**内存访问**	内存访问命令分两类。第一类是**算术操作和逻辑操作**，不仅可以操控寄存器，还可以操控指定的内存单元。第二类，所有计算机都会使用`load`和`store`命令，用来在寄存器和内存之间传递数据。这些命令可能会应用某些类型的寻址方式，在指令中指定目标内存单元的地址。三种绝大多数计算机支持的寻址方式：
 - ​	**直接寻址(Direct Addressing)**		最常用的寻址方式。直接 或 用符号表示内存单元的地址。

```haxe
LOAD R1, 67  // R1 <- Memory[67]
// 或者假设bar指向内存地址67，那么就有：
LOAD R1, bar  // R1 <- Memory[67]
```

- ​	**立即寻址(Direct Addressing)**		这种寻址方式用来加载常数——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。

```haxe
LOADI R1, 67  // R1 <- 67
```

- ​	**间接寻址(Direct Addressing)**		这种寻址方式用来处理**指针(pointer)**——也即是，将指令中数据域的内容当作要操作的数据加载到寄存器。

```haxe
// 将x = foo[j] or x = *(foo+j)翻译成汇编语言
ADD R1, foo, j  // R1 <- (foo+j)
LOAD* R2, R1  // R2 <- Memory[R1]，取值到R2
STR R2, x  // x <- R2，将值赋给x(内存单元)
```

​		当数组在高级语言程序(C/Java…)被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用foo来指代该内存单元组的**基地址(base address)**。于是当编译器以后遇到表示数组单元的符号**(eg: foo[j])**时，解析地址：`foo的基地址 + (j × 单个数组元素所占的字节)`。



​		**控制流程**		程序通常以先行执行，但也包含分支：**反复**(repetition, 跳回到循环的初始位置)、**有条件的执行**（conditional executioin, 若false向前跳到`if-then`语句之后）、**子程序调用**（subrouting calling, 跳到另一代码段的第一条命令处）

```haxe
// 高级实现
while (R1 >= 0){
    code 1
}
code 2
    
// 底层实现
// while循环结构的典型翻译
beginWhile
    JNG R1, endWhile  // if R1<0 goto endWhile
    // code 1 的翻译
JMP beginWhile  // goto beginWhile
endWhile:
	// code 2 的翻译
```



### [Hack机器语言规范详述]

#### 1.概述

​		Hack是一个基于冯·诺伊曼架构的16-位计算机，由一个CPU、两个独立的内存模块（instruction memory指令内存  和  data memory数据内存），以及两个内存映射I/O设备（显示器和键盘）组成。

​		**内存地址空间**		Hack程序员要了解，有两个不同的地址空间：**指令地址空间**（instruction memory**指令内存**），**数据地址空间**（data memory**数据内存**）。两个内存区16-位宽，由15-位地址空间，意味着两个内存可设定的最大地址都是`32K`的`16-bit word`**(2^15^ = 32 × 1024 = 32K)**

​		CPU只能执行存储在指令内存中的程序。指令内存是只读设备，程序通过某种外部方法被加载到指令内存中（加载新程序，就像游戏机更换游戏卡切换游戏）.  Hack平台的硬件仿真器提供一种方法，将某文本文件中用机器语言编写的程序加载到指令内存中。

​		**寄存器(Registers)**		Hack程序员要接触两个称为D和A的16-位寄存器，能够被算数和逻辑指令显式地操控(eg: `A = D-1`或`D = !A`)。D只作为数据寄存器（储存数据）；A既可以作为数据寄存器，也可以作为地址寄存器（储存地址）。

![三个寄存器](C4-机器语言.assets/image-20200827144620317.png)

​		Hack语言规定，内存的存取指令是对隐式的内存地址“M”进行操作。`M->A, A=512, M = memory[512]`



#### 2. A-指令 (地址指令)

唯一解释的命令：@value，为A寄存器赋值

```haxe
/* value:
 *  1.非负的十进制常数≤32767(=2^15 - 1)
 *  2.指向(非负的十进制常数)的符号, eg:sum
 */
@21：
 - A寄存器赋值为21
 - RAM[21]将成为选定的RAM寄存器
// 二进制形式：0value
```

​		只要赋值赋值给A寄存器，A寄存器会自动从数据存储器中选中被选择的寄存器，被选择的寄存器就是上图中的M寄存器。

```haxe
// Set RAM[100] to -1
@100  // A = 100, 二进制：0value(=0000 0000 0110 0100)
M = -1  // RAM[100] = -1
```

​		此段代码，M就是代表了内存单元中的寄存器[100]。这就是 A-指令 的用法，在内存的存取操作之前，我们总是要用 A-指令 去选择一个寄存器，进而完成内存的存取。



#### 3. C-指令

![C指令](C4-机器语言.assets/image-20200827153104413.png)

```haxe
// dest or jump are optional
// if dest is null, "=" omit
// if jump is null, ";" omit
C-instructions: dest = comp;jump
```

comp域：ALU计算什么；

dest域：计算后的结果（ALU的输出）将被存储到哪里；

jump域：接下来要取出并执行拿一条命令

```haxe
// Set the D register to -1
D = -1  // D in dest table, -1 in comp table
    
// Set RAM[300] to the value of the D register minus 1
@300  // A = 300, slect the register which I want to operate (access memory)
M = D-1  // (D-1) in comp table
    
// If (D-1 == 0) jump to execute the instruction stored in ROM[56]
@56  // A=56
D-1;JEQ  // if (D-1 == 0) go to 56.
// (D-1) in comp table, JEQ is (if out=0 then jump)
```

C-指令的二进制表示：

![C指令的二进制形式](C4-机器语言.assets/image-20200827160411973.png)

C-指令的compute域：

![C-指令的compute域](C4-机器语言.assets/image-20200827160756020.png)



C-指令的dest域：

![C-指令的dest域](C4-机器语言.assets/image-20200827160915065.png)

dest域为3位二进制组合，代表了8种可能。



C-指令的jump域：

![C-指令的jump域](C4-机器语言.assets/image-20200827161133846.png)与dest域相似，junp也是3位二进制组合。

特别的，最后一个指令`(0;JMP)`执行一个无条件跳转。（其实除了0，还可取任意数值）



#### 4. 符号

​		汇编命令可以使用常数或符号来表示内存单元位置（地址）。



#### 5. 输入/输出处理

![Screen memory map](C4-机器语言.assets/image-20200827164432945.png)

​		1 = 黑，0 = 白。而这中间的困难是，显示单元是二维的；内存地址是一维的，我们必须连接起来。我们只能从内存地址快中取出16位，而无法只访问一个单独的位。

​		对内存的存取操作都是16位，因此我们可以取出16位，对1位进行操作之后，再存放。

​		另一难题，如何在内存映射出对应的行-列？

​		1. `i = 32×row + col/16`

